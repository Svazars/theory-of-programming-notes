\documentclass[a4paper, 10pt]{extarticle}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{multirow} 
\usepackage{graphicx}
\usepackage{bm}
\usepackage{geometry}

\geometry{a4paper,top=2.5cm,bottom=2.5cm,bindingoffset=0cm}


\geometry{left=2cm,textwidth=18cm}
\linespread{1.0}
  
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{indentfirst}

\title{}
\author{Филатов А. Ю.}
\date{}

\newcommand{\Task}[1]{\textbf{Задача #1.}}
\newenvironment{faq}{\begin{description}[style=nextline]}{\end{description}}

\begin{document}
\section*{Часто задаваемые вопросы}

\begin{faq}
  \item[Можно выполнять все задания из списка заранее и получить баллы?]
    Да. Когда задачу разберем на семинаре -- она потеряет в цене.
  \item[Задания ``сформулировать ...'' и анализом сложности сдаются на семинарах?]
    Можно сдать листочек с разбором на семинаре. Можно прислать по почте .doc/.pdf файл или фотографию листочка.
  \item[Программы присылать, подставляя конкретные параметры, где нужно?]
    Для задач с параметрами, например ``сложить 2 числа в k-ричной системе'', надо: 
    \begin{itemize}
     \item написать одну программу для конкретного k (не такого, какой разбирали на семинарах),
     \item описать общий алгоритм -- как генерировать программу для произвольного k.  
    \end{itemize}

    \item[Как включить третью ленту для МТ? Ну, и, для будущего -- 4 или больше.]    
    Три бесконечные вправо ленты:
\begin{verbatim}
    tapes = [right, right, right]
\end{verbatim}

    \item[``Записанное наоборот'' число из задач к первому семинару — это как если бы лента уходила влево и мы писали число у её конца?]
    Число $12$ (в десятичной) будет записано на ленте вот так: $\#0011\#$.
    
    \item[Возможно ли в эмуляторе задать правило $\# \rightarrow aRR$ (несколько шагов)?]
    Нет, придется записывать как несколько правил.
\end{faq}
\newpage

\section{1-ленточные МТ}
В задачах данного раздела предполагается, что у МТ одна бесконечная вправо лента.

\Task{1.1} Написать программу прибавления 1 к двоичному числу, записанному "наоборот".
Провести анализ в среднем/в худшем. (Разбиралось на семинарах, 0 баллов).

\Task{1.2} Написать программу прибавления 1 к двоичному числу, записанному "правильно".
Провести анализ в среднем/в худшем. (1 балл).

\Task{1.3} Написать программу прибавления 3 к двоичному числу, записанному "наоборот". (Разбиралось на семинарах, 0 баллов).
Провести анализ в среднем/в худшем (в зависимости от простоты получившейся формулы для сложности в среднем, 1-3 балла).

\Task{1.4} Сформулировать, как пишется программа прибавления k к двоичному числу, записанному "наоборот". (Разбиралось на семинарах, 0 баллов).
Провести анализ в среднем/в худшем (в зависимости от простоты получившейся формулы для сложности в среднем, 1-3 балла).

\Task{1.5} Сформулировать, как пишется программа прибавления k к m-ричному числу, записанному "наоборот". (1 балл).

\Task{1.6} Написать программу разворота бинарной строки в алфавите $\{ \#, 0, 1\}$ (1 балл). Примеры:
\begin{verbatim}
    #       -> #
    #0#     -> #0#
    #01#    -> #10#
    #11001# -> #10011# 
\end{verbatim}
Провести анализ в среднем/в худшем (2 балла).

\Task{1.7} Алфавит =$\{\#, a, b\}$. Написать программу, которая находит самое левое вхождение подстроки "aababab" во входной строке и 
стирает с ленты все символы, ДО этого вхождения. Если искомая подстрока не нашлась -- лента должна быть пуста. (1 балл)
\begin{verbatim}
    #            -> #
    #ab#         -> #
    #aababab#    -> #aababab#
    #ababaababab#-> #####aababab#
\end{verbatim}
Доказать оптимальность в худшем случае (10 баллов.)


В задачах 1.8 - 1.9 предполагается, что если входные данные являются строкой из распознаваемого языка, то лента должна опустеть. 
Иначе -- программа должна перейти в ошибочное состояние.

\Task{1.8} Распознаватель $a^n b^n$ (0 баллов). См. samples.
Анализ в худшем/среднем (1 балл)

\Task{1.9} Распознаватель $a^n b^n c^n$ (1 балл).
Анализ в худшем/среднем (2 балла)

\Task{1.10} Алфавит = $\{\#, a, b\}$. Зафиксирована строка db = "aababababaabbbababaaab". 
Написать программу, которая проверяет, что строка, записанная на ленте, явлется подстрокой db. Если это так -- 
в конце работы программы лента должна стать пустой, иначе -- программа должна перейти в ошибочное состояние (1 балл). 
Если доказано, что решение оптимально -- еще 1 балл.

Примеры:
\begin{verbatim}
  # -> #
  #a# -> #
  #aaaa# -> Error
  #abababaa# -> #
\end{verbatim}

Рассчитать сложность в среднем (3 балла).

\newpage
\section{Многоленточные МТ}
В задачах данного раздела предполагается, что у МТ несколько лент с одинаковым алфавитом.

\Task{2.1} Написать программу перевода числа, записанного в двоичной системе, в восьмеричную. Считается, что число записано 
на первой ленте ``наоборот'', результат должен быть написан на второй ленте ``наоборот'', других изменений с лентами не должно произойти. 
Пример:
\begin{verbatim}
---------------------------
    #         -> #
    #         -> #
---------------------------
    #0#       -> #0#
    #         -> #0#
---------------------------
    #0001111# -> #0001111#
    #         -> #071# 
\end{verbatim}

Доказать оптимальность в худшем случае (2 балла).    

\Task{2.2} Написать программу перевода числа, записанного в троичной системе, в 11-ричную. Считается, что число записано на 
первой ленте ``наоборот'',  результат должен быть написан на третьей ленте ``наоборот''. Вторая лента для 
промежуточных вычислений. Перед завершением работы, программа должна очистить вторую ленту (заполнить символом $\#$). (2 балла).

\Task{2.3} Сложить 2 числа, записанных в k-ричной системе счисления и записать результат на третью ленту (1 балл). 
Выбрать $k \in \{5, 6, 7\}$.

\Task{2.4} Умножить 2 числа в k-ричной системе (1 балл).

\Task{2.5} Поделить нацело 2 числа в k-ричной системе (1 балл).

\Task{2.6} Поделить с остатком 2 числа в k-ричной системе (1 балл).

\Task{2.7} Алфавит = $\{a, b, c\}$, 2 ленты. На первой ленте записано слово $v = \#(a|b|c)^*\#$, на второй  $w = \#(a|b|c)^*\#$. 
Проверить, что $v$ является подстрокой $w$ (если ответ -- ``да'', то ленты должны остаться неизменными, иначе -- ошибка) (1 балл). 
Провести анализ в среднем (2 балла).

\section{RAM}
\subsection{Алгоритмы}
В каждой задаче данного раздела необходимо оценить сложность в худшем при равномерном весовом критерии.

\Task{3.1.1} Вывести последовательность чисел от $l$ до $r$ с шагом $s$, если $r \geq l$ (0.5 балла):
\begin{verbatim}
      in : l, r, s
      out: l, l+s, ..., r
\end{verbatim}


\Task{3.1.2.} Вывести числа в последовательности $a1, ..., an$, которые делятся без остатка на $d$ (0.5 балла):
\begin{verbatim}
       in : d, n, a1, ..., an
       out: b1, ..., bk
\end{verbatim}
       

\Task{3.1.3.} Определить, является ли последовательность $a1, ..., an$ палиндромом. 
Вывести $1$, если является, или $0$, если не является (1 балл):
\begin{verbatim}
       in : n, a1, ..., an
       out: r in {0,1}
\end{verbatim}

\Task{3.1.4.} Вывести двоичное представление десятичного числа.
\begin{itemize}
 \item least significant bit справа -- 0.5 
 \item LSB слева -- 0.5
\end{itemize}

\begin{verbatim}
       in : x  (1 регистр)
       out: y  (log2(x) регистров)
\end{verbatim}
       
\Task{3.1.5.} Определить, является ли последовательность $a1, ..., an$ отсортированной в порядке возрастания элементов, то есть 
$a1 \leq ... \leq an$. Вывести $1$, если является, или $0$, если не является (0.5 балла):
\begin{verbatim}
       in : n, a1, ..., an
       out: r in {0,1}
\end{verbatim}

\Task{3.1.6.} Отсортировать последовательность $a1, ..., an$ в порядке возрастания элементов:
\begin{itemize}
 \item Пузырек   - 0.5
 \item QuickSort - 1.5
 \item MergeSort - 1.5
 \item Любая другая сортировка 
 \begin{itemize}
  \item 1.0, если доказана сложность в среднем как $O(n log n)$, 
  \item 0.5, , если доказана сложность в среднем как $O(n^2)$. 
 \end{itemize}       
 \item Известно, что $|ai| \leq 100$. Реализовать сортировку подсчетом (сложность $O(n)$ при равномерном весовом критерии). 2 балла.
\end{itemize}
\begin{verbatim}
       in : n, a1, ... , an
       out: b1, ... , bn
\end{verbatim}

\Task{3.1.7.} Алгоритм быстрого возведения в степень.
\begin{verbatim}
       in : n
       out: n^n
\end{verbatim}
\begin{itemize}
  \item  0.5 - за работающее решение
  \item  1.0 - за решение, использующее $O(log_2(n))$ умножений
\end{itemize}
       
\Task{3.1.8.} Проверить, является ли входное число $n \geq 2$ простым (имеет ровно 2 делителя -- $1$ и $n$). 
Вывести $1$, если является, или $0$, если не является.
\begin{verbatim}
       in : n
       out: r in {0,1}
\end{verbatim}
0.5 балла за "наивную" реализацию. Использование нетривиальных алгоритмов поощряется дополнительными баллами.
    
\subsection{Program transformation and analysis}
\Task{3.2.1} Text relocation (2 балла).

Вход: $shift \geq 1, n \geq 0, A[0, 1,  ... , 2n-2, 2n-1]$, где $A$ -- корректная программа для RAM 
(каждая команда кодируется 2 регистрами -- опкод команды + аргумент). 

Выход: программа для RAM следующего вида:
\begin{verbatim}
    JUMP shift+1
    Halt 0
    ...
    Halt 0  (shift-1 раз)
    B[0]
    ...
    B[2n-1]
\end{verbatim}

Подразумевается, что B -- программа для RAM, отличающаяся от A тем, что аргументы инструкций JUMP, JZERO и JGTZ увеличены на shift.
Таким образом, результатом работы алгоритма является программа, полностью эквивалентная исходной (с той же словарной функцией).

\Task{3.2.2} Написать программу, которая печатает свой собственный текст (5 баллов).

\newpage
\section{RASP}

\Task{4.1} Загрузчик RASP программ (5 баллов). 

Вход: $n, A[0 ... 2n-1], arg_1, ..., arg_n$, где $A$ -- корректная программа для RASP (каждая команда 
кодируется 2 регистрами -- опкод команды + аргумент).

Необходимо загрузить $A$ в регистры $R_1, ..., R_{2n}$, занулить $R_0$, передать управление на $R_1$. 

\textbf{Замечание}: $arg_1 ... arg_n$ считывать с входной ленты НЕЛЬЗЯ.

Таким образом, результатом работы алгоритма является эмуляция входной программы на заданных аргументах.

\Task{4.2} Написать программу, которая печатает свой собственный текст (2 балла).

\end{document}
